---
category: manual
section: documentation
subsection: manual
title: Git - git-bundle Documentation
docname: git-bundle
lang: pt_BR
aliases:
- "/docs/git-bundle/pt_BR/index.html"

---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-bundle - Mova os objetos e as refs através do arquivo</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git bundle</em> create [-q | --quiet | --progress
		    [--version=&lt;versão&gt;] &lt;arquivo&gt; &lt;git-rev-list-args&gt;
<em>git bundle</em> verify [-q | --quiet] &lt;arquivo&gt;
<em>git bundle</em> list-heads &lt;arquivo&gt; [&lt;refname&gt;&#8230;&#8203;]
<em>git bundle</em> unbundle [--progress] &lt;arquivo&gt; [&lt;refname&gt;&#8230;&#8203;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Crie, desempacote e manipule os arquivos "bundle" (pacote). Os pacotes são usados para a transferência "offline" dos objetos Git sem um "servidor" ativo esperando do outro lado da conexão de rede.</p>
</div>
<div class="paragraph">
<p>Eles podem ser usados para criar backups incrementais e completos de um repositório e para retransmitir o estado das referências de um repositório para outro.</p>
</div>
<div class="paragraph">
<p>Os comandos do Git que buscam ou "leem" através de protocolos como <code>ssh://</code> e <code>https://</code> também podem operar nos arquivos de pacote (bundle). É possível <a href='{{< relurl "docs/git-clone/pt_BR" >}}'>git-clone[1]</a> (clonar) um novo repositório a partir de um pacote, usar o comando <a href='{{< relurl "docs/git-fetch/pt_BR" >}}'>git-fetch[1]</a> para buscar a partir de um e para listar as referências contidas nele usando o comando <a href='{{< relurl "docs/git-ls-remote/pt_BR" >}}'>git-ls-remote[1]</a>. Não há suporte correspondente de "gravação", ou seja, não há suporte para fazer um <em>git push</em> num pacote.</p>
</div>
<div class="paragraph">
<p>Consulte a seção de EXEMPLOS abaixo para mais exemplos de como usar.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_formato_bundle"><a class="anchor" href="#_formato_bundle"></a>FORMATO BUNDLE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Os pacotes são arquivos <code>.pack</code> (consulte <a href='{{< relurl "docs/git-pack-objects/pt_BR" >}}'>git-pack-objects[1]</a>) com um cabeçalho indicando quais as referências estão contidas nele.</p>
</div>
<div class="paragraph">
<p>Like the packed archive format itself bundles can either be self-contained, or be created using exclusions. See the "OBJECT PREREQUISITES" section below.</p>
</div>
<div class="paragraph">
<p>Os pacotes criados usando exclusões de revisão são "pacotes finos" criados usando a opção <code>--thin</code> para <a href='{{< relurl "docs/git-pack-objects/pt_BR" >}}'>git-pack-objects[1]</a> (empacotar os objetos), e descompactados usando a opção <code>--fix-thin</code> para <a href='{{< relurl "docs/git-index-pack/pt_BR" >}}'>git-index-pack[1]</a>.</p>
</div>
<div class="paragraph">
<p>Não há opção de criar um "pacote grosso" ao usar as exclusões de revisão, e os usuários não devem estar preocupados com essa diferença. Ao usar "pacotes finos", os pacotes "bundles" criados usando exclusões são menores em tamanho. A questão de serem "finos" sob o capô é meramente notado aqui como uma curiosidade e como uma referência a outra documentação.</p>
</div>
<div class="paragraph">
<p>Consulte <a href='{{< relurl "docs/gitformat-bundle/pt_BR" >}}'>gitformat-bundle[5]</a> para obter mais detalhes e informações sobre o "thin pack" em <a href='{{< relurl "docs/gitformat-pack/pt_BR" >}}'>gitformat-pack[5]</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-bundle-createoptionsltarquivogtltgit-rev-list-argsgt"> <a class="anchor" href="#git-bundle-createoptionsltarquivogtltgit-rev-list-argsgt"></a>create [options] &lt;arquivo&gt; &lt;git-rev-list-args&gt; </dt>
<dd>
<p>Used to create a bundle named <em>file</em>. This requires the <em>&lt;git-rev-list-args&gt;</em> arguments to define the bundle contents. <em>options</em> contains the options specific to the <em>git bundle create</em> subcommand. If <em>file</em> is <code>-</code>, the bundle is written to stdout.</p>
</dd>
<dt class="hdlist1" id="git-bundle-verifyltarquivogt"> <a class="anchor" href="#git-bundle-verifyltarquivogt"></a>verify &lt;arquivo&gt; </dt>
<dd>
<p>Used to check that a bundle file is valid and will apply cleanly to the current repository. This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. Then, <em>git bundle</em> prints a list of missing commits, if any. Finally, information about additional capabilities, such as "object filter", is printed. See "Capabilities" in <a href='{{< relurl "docs/gitformat-bundle/pt_BR" >}}'>gitformat-bundle[5]</a> for more information. The exit code is zero for success, but will be nonzero if the bundle file is invalid. If <em>file</em> is <code>-</code>, the bundle is read from stdin.</p>
</dd>
<dt class="hdlist1" id="git-bundle-list-headsltarquivogt"> <a class="anchor" href="#git-bundle-list-headsltarquivogt"></a>list-heads &lt;arquivo&gt; </dt>
<dd>
<p>Lists the references defined in the bundle. If followed by a list of references, only references matching those given are printed out. If <em>file</em> is <code>-</code>, the bundle is read from stdin.</p>
</dd>
<dt class="hdlist1" id="git-bundle-unbundleltarquivogt"> <a class="anchor" href="#git-bundle-unbundleltarquivogt"></a>unbundle &lt;arquivo&gt; </dt>
<dd>
<p>Passes the objects in the bundle to <em>git index-pack</em> for storage in the repository, then prints the names of all defined references. If a list of references is given, only references matching those in the list are printed. This command is really plumbing, intended to be called only by <em>git fetch</em>. If <em>file</em> is <code>-</code>, the bundle is read from stdin.</p>
</dd>
<dt class="hdlist1" id="git-bundle-ltgit-rev-list-argsgt"> <a class="anchor" href="#git-bundle-ltgit-rev-list-argsgt"></a>&lt;git-rev-list-args&gt; </dt>
<dd>
<p>A list of arguments, acceptable to <em>git rev-parse</em> and <em>git rev-list</em> (and containing a named ref, see SPECIFYING REFERENCES below), that specifies the specific objects and references to transport. For example, <code>master~10..master</code> causes the current master reference to be packaged along with all objects added since its 10th ancestor commit. There is no explicit limit to the number of references and objects that may be packaged.</p>
</dd>
<dt class="hdlist1" id="git-bundle-ltrefnamegt82308203"> <a class="anchor" href="#git-bundle-ltrefnamegt82308203"></a>[&lt;refname&gt;&#8230;&#8203;] </dt>
<dd>
<p>Uma lista de referências utilizadas para limitar as referências relatadas como disponíveis. É muito útil para ser utilizado com o <em>git fetch</em> que espera receber apenas as referências solicitadas e não necessariamente tudo no pacote (nesse caso, <em>git bundle</em> age como <em>git fetch-pack</em>).</p>
</dd>
<dt class="hdlist1" id="git-bundle---progress"> <a class="anchor" href="#git-bundle---progress"></a>--progress </dt>
<dd>
<p>É predefinido que a condição geral do progresso seja relatada no fluxo de erros quando estiver conectado num terminal, a menos que <code>-q</code> seja utilizado. Esta opção impõem a condição geral do progresso, mesmo que o fluxo de erro predefinido não seja direcionado para um terminal.</p>
</dd>
<dt class="hdlist1" id="git-bundle---versionltversogt"> <a class="anchor" href="#git-bundle---versionltversogt"></a>--version=&lt;versão&gt; </dt>
<dd>
<p>Specify the bundle version. Version 2 is the older format and can only be used with SHA-1 repositories; the newer version 3 contains capabilities that permit extensions. The default is the oldest supported format, based on the hash algorithm in use.</p>
</dd>
<dt class="hdlist1" id="git-bundle--q"> <a class="anchor" href="#git-bundle--q"></a>-q </dt>
<dt class="hdlist1" id="git-bundle---quiet"> <a class="anchor" href="#git-bundle---quiet"></a>--quiet </dt>
<dd>
<p>Esta opção faz com que o comando não relate o seu progresso em meio ao fluxo de erros já predefinido.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_especificando_as_referências"><a class="anchor" href="#_especificando_as_referências"></a>ESPECIFICANDO AS REFERÊNCIAS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As revisões devem ser acompanhadas pelos nomes de referência que serão empacotados num pacote (bundle).</p>
</div>
<div class="paragraph">
<p>More than one reference may be packaged, and more than one set of prerequisite objects can be specified. The objects packaged are those not contained in the union of the prerequisites.</p>
</div>
<div class="paragraph">
<p>O comando <em>git bundle create</em> resolve para você, os nomes de referência, usando as mesmas regras do comando <code>git rev-parse --abbrev-ref=loose</code>. Cada pré-requisito pode ser definido de forma explicita (como <code>^master~10</code> por exemplo) ou implicitamente (<code>master~10..master</code>, <code>--since=10.days.ago master</code> por exemplo).</p>
</div>
<div class="paragraph">
<p>Todos estes casos simples funcionam (assumindo que temos um ramo "master" e "next"):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create master.bundle master
$ echo master | git bundle create master.bundle --stdin
$ git bundle create master-and-next.bundle master next
$ (echo master; echo next) | git bundle create master-and-next.bundle --stdin</pre>
</div>
</div>
<div class="paragraph">
<p>E assim são estes (e os mesmos, mas omitidos, exemplos <code>--stdin</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create recent-master.bundle master~10..master
$ git bundle create recent-updates.bundle master~10..master next~5..next</pre>
</div>
</div>
<div class="paragraph">
<p>Um nome para a revisão ou intervalo não é aceito quando o lado direito não pode ser resolvido uma referência:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create HEAD.bundle $(git rev-parse HEAD)
fatal: Recusando a criação de um pacote vazio.
$ git bundle create master-yesterday.bundle master~10..master~5
fatal: Recusando a criação de um pacote vazio.</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pré_requisitos_do_objeto"><a class="anchor" href="#_pré_requisitos_do_objeto"></a>PRÉ-REQUISITOS DO OBJETO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ao criar os pacotes, é possível criar um pacote independente que pode ser descompactado num repositório sem um histórico em comum, além de fornecer revisões negativas para excluir objetos necessários nas partes anteriores do histórico.</p>
</div>
<div class="paragraph">
<p>A alimentação de uma revisão como <code>new</code> (nova) para <code>git bundle create</code> criará um arquivo pacote que contém todos os objetos acessíveis a partir da <code>nova</code> revisão. Esse pacote pode ser descompactado em qualquer repositório obtendo assim uma história completa que leva até à <code>nova</code> revisão:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create full.bundle new</pre>
</div>
</div>
<div class="paragraph">
<p>A revision range such as <code>old..new</code> will produce a bundle file that will require the revision <code>old</code> (and any objects reachable from it) to exist for the bundle to be "unbundle"-able:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create full.bundle old..new</pre>
</div>
</div>
<div class="paragraph">
<p>Um pacote independente e sem qualquer pré-requisito, pode ser extraído em qualquer lugar, mesmo num repositório vazio ou pode ser clonado a partir de (ou por exemplo, <code>new</code> mas não <code>old..new</code>).</p>
</div>
<div class="paragraph">
<p>É bom errar pelo excesso de zelo, fazendo com que o arquivo bundle (pacote) contenha os objetos já no destino, pois eles são ignorados durante a descompactação no destino.</p>
</div>
<div class="paragraph">
<p>If you want to match <code>git clone --mirror</code>, which would include your refs such as <code>refs/remotes/*</code>, use <code>--all</code>. If you want to provide the same set of refs that a clone directly from the source repository would get, use <code>--branches --tags</code> for the <code>&lt;git-rev-list-args&gt;</code>.</p>
</div>
<div class="paragraph">
<p>O comando <em>git bundle verify</em> pode ser usado para verificar se o repositório do destinatário tem os pré-requisitos necessários para fazer o commit de um pacote.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos"><a class="anchor" href="#_exemplos"></a>EXEMPLOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Assume you want to transfer the history from a repository R1 on machine A to another repository R2 on machine B. For whatever reason, direct connection between A and B is not allowed, but we can move data from A to B via some mechanism (CD, email, etc.). We want to update R2 with development made on the branch master in R1.</p>
</div>
<div class="paragraph">
<p>Para inicializar o processo, você pode primeiro criar um pacote que não exista qualquer pré-requisitos. Você pode usar uma tag para ser lembrado até o último commit que for processado, serve para facilitar a atualização posterior do outro repositório com um pacote incremental:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>machineA$ cd R1
machineA$ git bundle create file.bundle master
machineA$ git tag -f lastR2bundle master</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, você transfere <code>file.bundle</code> para a máquina no destino B. Como esse pacote não requer que nenhum objeto existente seja extraído, você pode criar um novo repositório na máquina B clonando a partir dele:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>machineB$ git clone -b master /home/me/tmp/file.bundle R2</pre>
</div>
</div>
<div class="paragraph">
<p>Isso irá definir um ponto remoto chamado "origin" (origem) no repositório que permite que você capture e extraia do pacote. O arquivo <code>$GIT_DIR/config</code> no R2 terá uma entrada como esta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[remote "origin"]
    url = /home/me/tmp/file.bundle
    fetch = refs/heads/*:refs/remotes/origin/*</pre>
</div>
</div>
<div class="paragraph">
<p>Para atualizar o repositório <code>mine.git</code>, você pode capturar ou extrair após a reposição do pacote armazenado em <code>/home/me/tmp/file.bundle</code> com as atualizações incrementais.</p>
</div>
<div class="paragraph">
<p>Depois de trabalhar um pouco mais no repositório original, você pode criar um pacote incremental para atualizar um outro repositório:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>machineA$ cd R1
machineA$ git bundle create file.bundle lastR2bundle..master
machineA$ git tag -f lastR2bundle master</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, você transfere o pacote para uma outra máquina para substituir o <code>/home/me/tmp/file.bundle</code> e captura dele.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>machineB$ cd R2
machineB$ git pull</pre>
</div>
</div>
<div class="paragraph">
<p>Caso saiba até qual commit do repositório nos destinatários pretendidos devem ter os objetos necessários, você poderá utilizar este conhecimento para definir o pré-requisito, informando um ponto de corte para limitar as revisões e os objetos inclusos no pacote. O exemplo anterior utilizou a tag <code>lastR2bundle</code> para essa finalidade, porém é possível utilizar outras opções que você daria ao comando <a href='{{< relurl "docs/git-log/pt_BR" >}}'>git-log[1]</a>. Aqui mais alguns exemplos:</p>
</div>
<div class="paragraph">
<p>Você pode utilizar uma tag que esteja presente em ambos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create mybundle v1.0.0..master</pre>
</div>
</div>
<div class="paragraph">
<p>Você pode utilizar um pré-requisito utilizando o tempo como referência:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create mybundle --since=10.days master</pre>
</div>
</div>
<div class="paragraph">
<p>Você pode utilizar a quantidade dos commits:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create mybundle -10 master</pre>
</div>
</div>
<div class="paragraph">
<p>Você pode executar o comando <code>git-bundle verify</code> para ver se você consegue extrair de um pacote que foi criado com um pré-requisito:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle verify mybundle</pre>
</div>
</div>
<div class="paragraph">
<p>Isso listará quais os commits você deve ter para extrair do pacote e encerrará com um erro caso você não os tenha.</p>
</div>
<div class="paragraph">
<p>Um pacote do ponto de vista de um repositório do destinatário é como um repositório regular do qual ele captura ou extrai. Você pode, por exemplo, durante a captura é possível mapear quais são as referências:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fetch mybundle master:localRef</pre>
</div>
</div>
<div class="paragraph">
<p>Você também pode ver quais são as referências que ela oferece:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git ls-remote mybundle</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_formato_do_arquivo"><a class="anchor" href="#_formato_do_arquivo"></a>FORMATO DO ARQUIVO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Consulte <a href='{{< relurl "docs/gitformat-bundle/pt_BR" >}}'>gitformat-bundle[5]</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>