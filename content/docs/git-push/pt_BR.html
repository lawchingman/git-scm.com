---
category: manual
section: documentation
subsection: manual
title: Git - git-push Documentation
docname: git-push
lang: pt_BR
aliases:
- "/docs/git-push/pt_BR/index.html"

---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-push - Atualiza as refs remotas junto com os objetos associados a ela</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git push</em> [--all | --branches | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=&lt;git-receive-pack&gt;]
	   [--repo=&lt;repositório&gt;] [-f | --force] [-d | --delete] [--prune] [-q | --quiet] [-v | --verbose]
	   [-u | --set-upstream] [-o &lt;texto&gt; | --push-option=&lt;texto&gt;]
	   [--[no-]signed|--signed=(true|false|if-asked)]
	   [--force-with-lease[=&lt;refname&gt;[:&lt;expect&gt;]] [--force-if-includes]]
	   [--no-verify] [&lt;repositório&gt; [&lt;refspec&gt;&#8230;&#8203;]]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Atualiza as refs remotas utilizando as refs locais, enquanto envia os objetos necessários para que seja concluída as refs informadas.</p>
</div>
<div class="paragraph">
<p>You can make interesting things happen to a repository every time you push into it, by setting up <em>hooks</em> there. See documentation for <a href='{{< relurl "docs/git-receive-pack/pt_BR" >}}'>git-receive-pack[1]</a>.</p>
</div>
<div class="paragraph">
<p>When the command line does not specify where to push with the <code>&lt;repository&gt;</code> argument, <code>branch.*.remote</code> configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to <em>origin</em>.</p>
</div>
<div class="paragraph">
<p>Quando a linha de comando não especifica o que impulsionar (push) com as opções <code>&lt;refspec&gt;...</code> ou com as opções <code>--all</code>, <code>--mirror</code>, <code>--tags</code>, o comando encontra a predefinição <code>&lt;refspec&gt;</code> consultando a configuração <code>remote.*.push</code> e caso ainda não tenha sido encontrado, honra a configuração do <code>push.default</code> para decidir o que enviar (para saber o significado de <code>push.default</code> consulte<a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</div>
<div class="paragraph">
<p>Quando nem a linha de comando nem a configuração informam o que enviar, o comportamento predefinido é utilizado, que corresponde ao valor <code>simple</code> para <code>push.default</code>: o ramo atual é enviado ao ramo upstream correspondente, porém como uma medida segurança, o envio será cancelado caso o ramo upstream não esteja com o mesmo nome que o ramo local.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_options"><a class="anchor" href="#_options"></a>OPTIONS<a id="OPTIONS"></a></h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-push-ltrepositriogt"> <a class="anchor" href="#git-push-ltrepositriogt"></a>&lt;repositório&gt; </dt>
<dd>
<p>The "remote" repository that is the destination of a push operation. This parameter can be either a URL (see the section <a href="#URLS">GIT URLS</a> below) or the name of a remote (see the section <a href="#REMOTES">REMOTES</a> below).</p>
</dd>
<dt class="hdlist1" id="git-push-ltrefspecgt82308203"> <a class="anchor" href="#git-push-ltrefspecgt82308203"></a>&lt;refspec&gt;&#8230;&#8203; </dt>
<dd>
<p>Specify what destination ref to update with what source object. The format of a &lt;refspec&gt; parameter is an optional plus <code>+</code>, followed by the source object &lt;src&gt;, followed by a colon <code>:</code>, followed by the destination ref &lt;dst&gt;.</p>
<div class="paragraph">
<p>Geralmente <code>&lt;src&gt;</code> é o nome do ramo que você deseja impulsionar, pode ser qualquer "expressão SHA-1" arbitrária, como <code>master~4</code> ou <code>HEAD</code> (consulte <a href='{{< relurl "docs/gitrevisions/pt_BR" >}}'>gitrevisions[7]</a>).</p>
</div>
<div class="paragraph">
<p>The &lt;dst&gt; tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named. If <code>git push [&lt;repository&gt;]</code> without any <code>&lt;refspec&gt;</code> argument is set to update some ref at the destination with <code>&lt;src&gt;</code> with <code>remote.&lt;repository&gt;.push</code> configuration variable, <code>:&lt;dst&gt;</code> part can be omitted&#8212;&#8203;such a push will update a ref that <code>&lt;src&gt;</code> normally updates without any <code>&lt;refspec&gt;</code> on the command line. Otherwise, missing <code>:&lt;dst&gt;</code> means to update the same ref as the <code>&lt;src&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Caso o &lt;dst&gt; não comece com <code>refs/</code> (como <code>refs/heads/master</code> por exemplo), tentaremos inferir onde em <code>refs/*</code> no &lt;repositório&gt; de destino, ele pertença com base no tipo da &lt;src&gt; sendo impulsionado e caso o &lt;dst&gt; seja ambíguo.</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Caso o &lt;dst&gt; se refira inequivocamente a uma "ref" no &lt;repositório&gt; do ramo remoto, então faça um impulsionamento "push" nesta ref.</p>
</li>
<li>
<p>Caso o &lt;src&gt; seja resolvido para uma "ref" começando com <code>refs/heads/</code> ou <code>refs/tags/</code>, coloque um prefixo no &lt;dst&gt;.</p>
</li>
<li>
<p>Outras resoluções de ambiguidade podem ser adicionadas no futuro, mas, por enquanto, outros casos apresentarão um erro indicando o que tentamos e dependendo da configuração <code>advice.pushUnqualifiedRefname</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>), sugere qual <em>refs/ namespace</em> você possa querer impulsionar.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>O objeto referenciado por &lt;src&gt; é utilizado para atualizar a referência &lt;dst&gt; no lado remoto. Caso isso seja permitido, vai depender de onde em <code>refs/*</code> a referência &lt;dst&gt; vive como descrito com mais detalhes logo abaixo, nestas seções "update" indica que quaisquer modificações, exceto as exclusões, que serão descritos nas próximas seções, são tratadas de forma diferente.</p>
</div>
<div class="paragraph">
<p>O espaço de nomes <code>refs/heads/*</code> aceitarão apenas os objetos commit e será atualizado apenas caso eles possam avançar de forma rápida.</p>
</div>
<div class="paragraph">
<p>O espaço de nomes <code>refs/tags/*</code> aceitarão quaisquer tipos de objeto (como commits, árvores e bolhas que possam ser marcados) e quaisquer atualizações para eles serão rejeitadas.</p>
</div>
<div class="paragraph">
<p>É possível impulsionar qualquer tipo de objeto para qualquer espaço de nomes fora do <code>refs/{tags,heads}/*</code>. No caso das tags e dos commits, estes serão tratados como se fossem os commits dentro do <code>refs/heads/*</code> para os propósitos caso a atualização seja permitida.</p>
</div>
<div class="paragraph">
<p>Um avanço rápido dos commits e das tags fora do <code>refs/{tags,heads}/*</code> por exemplo, é permitido, mesmo nos casos onde o que está sendo acelerado não é um commit e sim um objeto da tag que aponte para um novo commit onde seja um avanço rápido do commit da última tag (ou commit) que está sendo substituindo. Também é permitida a reposição de uma tag por uma outra totalmente diferente, caso ela apontar para o mesmo commit, bem como ao impulsionar uma tag já descascada, ou seja, impulsionar o commit onde o objeto existente do tag aponte ou um novo objeto da tag onde o commit existente esteja apontando.</p>
</div>
<div class="paragraph">
<p>Os objetos da árvore e da bolha fora do <code>refs{tags,heads}/*</code> serão tratados da mesma maneira como se estivessem dentro do <code>refs/tags/*</code>, qualquer outra atualização deles será rejeitada.</p>
</div>
<div class="paragraph">
<p>Todas as regras descritas acima sobre o que não é permitido como uma atualização, podem ser substituídas adicionando um sinal opcional <code>+</code> inicial num "refspec" (ou utilizando a opção da linha de comando <code>--force</code>). A única exceção a isso é que nenhuma quantidade de imposição fará com que o espaço de nomes <code>refs/heads/*</code> aceite um objeto que não seja um commit. Os ganchos e configurações também podem substituir ou alterar estas regras, consulte, por exemplo, <code>receive.denyNonFastForwards</code> no <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a> e <code>pre-receive</code> e <code>update</code> no <a href='{{< relurl "docs/githooks/pt_BR" >}}'>githooks[5]</a>.</p>
</div>
<div class="paragraph">
<p>Fazer um impulsionamento "push" de um &lt;src&gt; vazio permite excluir o &lt;dst&gt; "ref" do repositório remoto. As exclusões sempre são aceitas sem um sinal <code>+</code> inicial no "refspec" (ou com a opção <code>--force</code>), exceto quando for proibido pela configuração ou pelos ganchos. Consulte <code>receive.denyDeletes</code> no <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a> e <code>pre-receive</code> e <code>update</code> no <a href='{{< relurl "docs/githooks/pt_BR" >}}'>githooks[5]</a>.</p>
</div>
<div class="paragraph">
<p>The special refspec <code>:</code> (or <code>+:</code> to allow non-fast-forward updates) directs Git to push "matching" branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side.</p>
</div>
<div class="paragraph">
<p>A <code>tag &lt;tag&gt;</code> significa o mesmo que <code>refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-push---all"> <a class="anchor" href="#git-push---all"></a>--all </dt>
<dt class="hdlist1" id="git-push---branches"> <a class="anchor" href="#git-push---branches"></a>--branches </dt>
<dd>
<p>impulsione todos os ramos (ou seja, refs em <code>refs/heads/</code>); não pode ser utilizado com outro &lt;refspec&gt;.</p>
</dd>
<dt class="hdlist1" id="git-push---prune"> <a class="anchor" href="#git-push---prune"></a>--prune </dt>
<dd>
<p>Remove remote branches that don&#8217;t have a local counterpart. For example a remote branch <code>tmp</code> will be removed if a local branch with the same name doesn&#8217;t exist any more. This also respects refspecs, e.g. <code>git push --prune remote refs/heads/*:refs/tmp/*</code> would make sure that remote <code>refs/tmp/foo</code> will be removed if <code>refs/heads/foo</code> doesn&#8217;t exist.</p>
</dd>
<dt class="hdlist1" id="git-push---mirror"> <a class="anchor" href="#git-push---mirror"></a>--mirror </dt>
<dd>
<p>Instead of naming each ref to push, specifies that all refs under <code>refs/</code> (which includes but is not limited to <code>refs/heads/</code>, <code>refs/remotes/</code>, and <code>refs/tags/</code>) be mirrored to the remote repository. Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end. This is the default if the configuration option <code>remote.&lt;remote&gt;.mirror</code> is set.</p>
</dd>
<dt class="hdlist1" id="git-push--n"> <a class="anchor" href="#git-push--n"></a>-n </dt>
<dt class="hdlist1" id="git-push---dry-run"> <a class="anchor" href="#git-push---dry-run"></a>--dry-run </dt>
<dd>
<p>Faça tudo, exceto realmente enviar as atualizações.</p>
</dd>
<dt class="hdlist1" id="git-push---porcelain"> <a class="anchor" href="#git-push---porcelain"></a>--porcelain </dt>
<dd>
<p>Produce machine-readable output. The output status line for each ref will be tab-separated and sent to stdout instead of stderr. The full symbolic names of the refs will be given.</p>
</dd>
<dt class="hdlist1" id="git-push--d"> <a class="anchor" href="#git-push--d"></a>-d </dt>
<dt class="hdlist1" id="git-push---delete"> <a class="anchor" href="#git-push---delete"></a>--delete </dt>
<dd>
<p>Todas as refs listadas são excluídas do repositório remoto. É o mesmo que prefixar todos as refs com dois pontos.</p>
</dd>
<dt class="hdlist1" id="git-push---tags"> <a class="anchor" href="#git-push---tags"></a>--tags </dt>
<dd>
<p>Todas as refs no <code>refs/tags</code> são impulsionadas, além das "refspecs" que forem explicitamente listados na linha de comando.</p>
</dd>
<dt class="hdlist1" id="git-push---follow-tags"> <a class="anchor" href="#git-push---follow-tags"></a>--follow-tags </dt>
<dd>
<p>Push all the refs that would be pushed without this option, and also push annotated tags in <code>refs/tags</code> that are missing from the remote but are pointing at commit-ish that are reachable from the refs being pushed. This can also be specified with configuration variable <code>push.followTags</code>. For more information, see <code>push.followTags</code> in <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-push---no-signed"> <a class="anchor" href="#git-push---no-signed"></a>--[no-]signed </dt>
<dt class="hdlist1" id="git-push---signedtruefalseif-asked"> <a class="anchor" href="#git-push---signedtruefalseif-asked"></a>--signed=(true|false|if-asked) </dt>
<dd>
<p>GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged. If <code>false</code> or <code>--no-signed</code>, no signing will be attempted. If <code>true</code> or <code>--signed</code>, the push will fail if the server does not support signed pushes. If set to <code>if-asked</code>, sign if and only if the server supports signed pushes. The push will also fail if the actual call to <code>gpg --sign</code> fails. See <a href='{{< relurl "docs/git-receive-pack/pt_BR" >}}'>git-receive-pack[1]</a> for the details on the receiving end.</p>
</dd>
<dt class="hdlist1" id="git-push---no-atomic"> <a class="anchor" href="#git-push---no-atomic"></a>--[no-]atomic </dt>
<dd>
<p>Use an atomic transaction on the remote side if available. Either all refs are updated, or on error, no refs are updated. If the server does not support atomic pushes the push will fail.</p>
</dd>
<dt class="hdlist1" id="git-push--oltopogt"> <a class="anchor" href="#git-push--oltopogt"></a>-o &lt;opção&gt; </dt>
<dt class="hdlist1" id="git-push---push-optionltopogt"> <a class="anchor" href="#git-push---push-optionltopogt"></a>--push-option=&lt;opção&gt; </dt>
<dd>
<p>Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple <code>--push-option=&lt;option&gt;</code> are given, they are all sent to the other side in the order listed on the command line. When no <code>--push-option=&lt;option&gt;</code> is given from the command line, the values of configuration variable <code>push.pushOption</code> are used instead.</p>
</dd>
<dt class="hdlist1" id="git-push---receive-packltgit-receive-packgt"> <a class="anchor" href="#git-push---receive-packltgit-receive-packgt"></a>--receive-pack=&lt;git-receive-pack&gt; </dt>
<dt class="hdlist1" id="git-push---execltgit-receive-packgt"> <a class="anchor" href="#git-push---execltgit-receive-packgt"></a>--exec=&lt;git-receive-pack&gt; </dt>
<dd>
<p>Path to the <em>git-receive-pack</em> program on the remote end. Sometimes useful when pushing to a remote repository over ssh, and you do not have the program in a directory on the default $PATH.</p>
</dd>
<dt class="hdlist1" id="git-push---no-force-with-lease"> <a class="anchor" href="#git-push---no-force-with-lease"></a>--[no-]force-with-lease </dt>
<dt class="hdlist1" id="git-push---force-with-leaseltrefnamegt"> <a class="anchor" href="#git-push---force-with-leaseltrefnamegt"></a>--force-with-lease=&lt;refname&gt; </dt>
<dt class="hdlist1" id="git-push---force-with-leaseltrefnamegtltexpectgt"> <a class="anchor" href="#git-push---force-with-leaseltrefnamegtltexpectgt"></a>--force-with-lease=&lt;refname&gt;:&lt;expect&gt; </dt>
<dd>
<p>Normalmente, o comando "git push" se recusa a atualizar uma "ref" remota que não seja um ancestral da "ref" local utilizada para substituí-la.</p>
<div class="paragraph">
<p>This option overrides this restriction if the current value of the remote ref is the expected value. "git push" fails otherwise.</p>
</div>
<div class="paragraph">
<p>Imagine that you have to rebase what you have already published. You will have to bypass the "must fast-forward" rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with their commit, and blindly pushing with <code>--force</code> will lose their work.</p>
</div>
<div class="paragraph">
<p>Esta opção permite que você diga que vai esperar que o histórico que está sendo atualizando seja o que você reconstruiu com o "rebase" e vai querer substituir. Casi uma "ref" remota ainda aponte para um commit específico, você pode ter certeza que outras pessoas não fizeram nada com a "ref". É como fazer uma "concessão" na ref sem bloqueá-la diretamente, a "ref" remota será atualizada apenas caso a "concessão" ainda seja válida.</p>
</div>
<div class="paragraph">
<p>Somente a opção <code>--force-with-lease</code>, sem qualquer outra definição, protegerá todos as refs remotas que serão atualizadas, exigindo que o seu valor atual seja o mesmo que o ramo monitorado remotamente que temos para eles.</p>
</div>
<div class="paragraph">
<p>A opção <code>--force-with-lease=&lt;refname&gt;</code>, sem qualquer outro valor esperado, protegerá a "ref" que foi informado (sozinho), caso seja atualizado, exigindo que o seu valor atual seja o mesmo que o ramo monitorado remotamente que temos para isso.</p>
</div>
<div class="paragraph">
<p><code>--force-with-lease=&lt;refname&gt;:&lt;expect&gt;</code> will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the specified value <code>&lt;expect&gt;</code> (which is allowed to be different from the remote-tracking branch we have for the refname, or we do not even have to have such a remote-tracking branch when this form is used). If <code>&lt;expect&gt;</code> is the empty string, then the named ref must not already exist.</p>
</div>
<div class="paragraph">
<p>Observe que todas as formas diferentes da opção <code>--force-with-lease=&lt;refname&gt;:&lt;expect&gt;</code> que define o valor atual esperado para a "ref" de forma explicita, ainda são experimentais e sua semântica pode mudar à medida que adquiramos mais experiência com este recurso.</p>
</div>
<div class="paragraph">
<p>A opção <code>--no-force-with-lease</code> cancelará todos os <code>--force-with-lease</code> anteriores na linha de comando.</p>
</div>
<div class="paragraph">
<p>Uma observação geral sobre a segurança: utilizar esta opção sem um valor esperado, por exemplo, <code>--force-with-lease</code> ou <code>--force-with-lease=&lt;refname&gt;</code> interage muito mal com qualquer coisa que execute de forma implícita o comando <code>git fetch</code> do ramo remoto que será encaminhado para um processo de segundo plano, como o comando <code>git fetch origin</code> no seu repositório para um trabalho agendado "cronjob" por exemplo.</p>
</div>
<div class="paragraph">
<p>A proteção oferecida contra a opção <code>--force</code> é garantir que as subsequentes alterações onde a base do seu trabalho não sejam prejudicadas, porém isso será derrotado trivialmente caso algum processo em segundo plano estiver atualizando as refs em segundo plano. Não temos nada além das informações de monitoramento remoto, como uma heurística para as refs que você deve ter visto e está disposto a adotar.</p>
</div>
<div class="paragraph">
<p>Caso o seu editor ou um outro sistema esteja executando o comando <code>git fetch</code> no segundo plano para você, uma maneira de atenuar isso é simplesmente configurar um outro ramo remoto:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git remote add origin-push $(git config remote.origin.url)
git fetch origin-push</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, quando o processo em segundo plano executar o comando <code>git fetch origin</code>, as referências no <code>origin-push</code> não serão atualizadas e portanto, comandos como:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git push --force-with-lease origin-push</pre>
</div>
</div>
<div class="paragraph">
<p>Irá falhar a menos que você execute manualmente o comando <code>git fetch origin-push</code>. É claro que esse método será totalmente derrotado por algo que execute o comando <code>git fetch --all</code>, neste caso, você precisa desativá-lo ou fazer algo mais tedioso como:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git fetch              # atualiza o 'master' remotamente
git tag base master    # marca o ponto da nossa base
git rebase -i master   # reescreve alguns commits
git push --force-with-lease=master:base master:master</pre>
</div>
</div>
<div class="paragraph">
<p>Crie uma tag <code>base</code> para as versões do código upstream que você viu e está disposto a sobrescrever por exemplo, depois reescreva o histórico e finalmente, imponha um impulsionamento "push" com as alterações para <code>master</code> caso a versão remota ainda esteja na <code>base</code>, independentemente se os seus ramos <code>remotes/origin/master</code> locais foram atualizados em segundo plano ou não.</p>
</div>
<div class="paragraph">
<p>Alternativamente, ao usar a opção <code>--force-if-includes</code> como uma opção auxiliar em conjunto com <code>--force-with-lease[=&lt;refname&gt;]</code> (sem dizer qual o ref exato do commit remoto, ou quais os refs remotos que estão sendo protegidos por exemplo) no momento do "push", irá verificar se as atualizações a partir dos refs monitorados remotamente tenham sido atualizados de forma implicita em segundo plano e se estão sendo integrados localmente antes de permitir uma atualização forçada.</p>
</div>
</dd>
<dt class="hdlist1" id="git-push--f"> <a class="anchor" href="#git-push--f"></a>-f </dt>
<dt class="hdlist1" id="git-push---force"> <a class="anchor" href="#git-push---force"></a>--force </dt>
<dd>
<p>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when <code>--force-with-lease</code> option is used, the command refuses to update a remote ref whose current value does not match what is expected.</p>
<div class="paragraph">
<p>Esta opção desativa estas verificações e pode causar a perda do commit no repositório remoto; utilize com cuidado.</p>
</div>
<div class="paragraph">
<p>Note that <code>--force</code> applies to all the refs that are pushed, hence using it with <code>push.default</code> set to <code>matching</code> or with multiple push destinations configured with <code>remote.*.push</code> may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart). To force a push to only one branch, use a <code>+</code> in front of the refspec to push (e.g <code>git push origin +master</code> to force a push to the <code>master</code> branch). See the <code>&lt;refspec&gt;...</code> section above for details.</p>
</div>
</dd>
<dt class="hdlist1" id="git-push---no-force-if-includes"> <a class="anchor" href="#git-push---no-force-if-includes"></a>--[no-]force-if-includes </dt>
<dd>
<p>Impõem uma atualização apenas se o topo da ref monitorada remotamente estiver integrada localmente.</p>
<div class="paragraph">
<p>Esta opção permite uma checagem que verifica se o topo da referência monitorada remotamente é alcançável a partir de uma das entradas "reflog" do ramo local e feita com base nela para uma reescrita. A verificação assegura que quaisquer atualizações do ramo remoto foram incorporadas localmente, rejeitando a atualização forçada se não for esse o caso.</p>
</div>
<div class="paragraph">
<p>Nenhuma operação será feita caso a opção seja usada sem definir <code>--force-with-lease</code> ou se definir junto com <code>--force-with-lease=&lt;refname&gt;:&lt;expect&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Usando a opção <code>--no-force-if-includes</code> desativa este comportamento.</p>
</div>
</dd>
<dt class="hdlist1" id="git-push---repoltrepositriogt"> <a class="anchor" href="#git-push---repoltrepositriogt"></a>--repo=&lt;repositório&gt; </dt>
<dd>
<p>Esta opção é equivalente ao argumento &lt;repositório&gt;. Caso ambos sejam utilizados, o argumento da linha de comandos terá a prioridade.</p>
</dd>
<dt class="hdlist1" id="git-push--u"> <a class="anchor" href="#git-push--u"></a>-u </dt>
<dt class="hdlist1" id="git-push---set-upstream"> <a class="anchor" href="#git-push---set-upstream"></a>--set-upstream </dt>
<dd>
<p>Para cada ramo atualizado ou impulsionada com êxito, adicione uma referência "upstream" (monitorado), utilizada sem argumento pelo <a href='{{< relurl "docs/git-pull/pt_BR" >}}'>git-pull[1]</a> e os outros comandos. Para mais informações, consulte <code>branch.&lt;nome&gt;.merge</code> no <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-push---no-thin"> <a class="anchor" href="#git-push---no-thin"></a>--[no-]thin </dt>
<dd>
<p>Estas opções são passadas para o <a href='{{< relurl "docs/git-send-pack/pt_BR" >}}'>git-send-pack[1]</a>. Uma pequena transferência "thin" reduz significativamente a quantidade dos dados enviados quando o remetente e o destinatário compartilham muito dos mesmos objetos em comum. A predefinição é <code>--thin</code>.</p>
</dd>
<dt class="hdlist1" id="git-push--q"> <a class="anchor" href="#git-push--q"></a>-q </dt>
<dt class="hdlist1" id="git-push---quiet"> <a class="anchor" href="#git-push---quiet"></a>--quiet </dt>
<dd>
<p>Suprima tudo o que for gerado, incluindo a listagem das atualizações das refs, a menos que um erro aconteça. O progresso não é relatado para o fluxo de erro predefinido.</p>
</dd>
<dt class="hdlist1" id="git-push--v"> <a class="anchor" href="#git-push--v"></a>-v </dt>
<dt class="hdlist1" id="git-push---verbose"> <a class="anchor" href="#git-push---verbose"></a>--verbose </dt>
<dd>
<p>Rode de forma loquaz.</p>
</dd>
<dt class="hdlist1" id="git-push---progress"> <a class="anchor" href="#git-push---progress"></a>--progress </dt>
<dd>
<p>É predefinido que a condição geral do progresso seja relatada no fluxo de erros quando estiver conectado num terminal, a menos que <code>-q</code> seja utilizado. Esta opção impõem a condição geral do progresso, mesmo que o fluxo de erro predefinido não seja direcionado para um terminal.</p>
</dd>
<dt class="hdlist1" id="git-push---no-recurse-submodules"> <a class="anchor" href="#git-push---no-recurse-submodules"></a>--no-recurse-submodules </dt>
<dt class="hdlist1" id="git-push---recurse-submodulescheckon-demandonlyno"> <a class="anchor" href="#git-push---recurse-submodulescheckon-demandonlyno"></a>--recurse-submodules=check|on-demand|only|no </dt>
<dd>
<p>May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If <em>check</em> is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If <em>on-demand</em> is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If <em>only</em> is used all submodules will be pushed while the superproject is left unpushed. A value of <em>no</em> or using <code>--no-recurse-submodules</code> can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required.</p>
<div class="paragraph">
<p>Ao usar <em>on-demand</em> ou <em>only</em>, caso um submódulo tenha uma configuração "push.recurseSubmodules={on-demand,only}" ou "submodule.recurse", haverá uma recursão adicional. Nesse caso, "only" é tratado como "on-demand"(sob demanda).</p>
</div>
</dd>
<dt class="hdlist1" id="git-push---no-verify"> <a class="anchor" href="#git-push---no-verify"></a>--[no-]verify </dt>
<dd>
<p>Toggle the pre-push hook (see <a href='{{< relurl "docs/githooks/pt_BR" >}}'>githooks[5]</a>). The default is --verify, giving the hook a chance to prevent the push. With --no-verify, the hook is bypassed completely.</p>
</dd>
<dt class="hdlist1" id="git-push--4"> <a class="anchor" href="#git-push--4"></a>-4 </dt>
<dt class="hdlist1" id="git-push---ipv4"> <a class="anchor" href="#git-push---ipv4"></a>--ipv4 </dt>
<dd>
<p>Utilize apenas os endereços IPv4, ignorando os endereços IPv6.</p>
</dd>
<dt class="hdlist1" id="git-push--6"> <a class="anchor" href="#git-push--6"></a>-6 </dt>
<dt class="hdlist1" id="git-push---ipv6"> <a class="anchor" href="#git-push---ipv6"></a>--ipv6 </dt>
<dd>
<p>Utilize apenas os endereços IPv6, ignorando os endereços IPv4.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git_urls"><a class="anchor" href="#_git_urls"></a>GIT URLS<a id="URLS"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Em geral as URLs contêm informações sobre o protocolo de transporte, o endereço do servidor remoto e o caminho para o repositório. Dependendo do protocolo de transporte, algumas dessas informações podem estar ausentes.</p>
</div>
<div class="paragraph">
<p>O Git suporta os protocolos ssh, git, http e https (além do ftp e ftps podem ser utilizados para captura (feching), porém é ineficiente e obsoleto; não os utilize).</p>
</div>
<div class="paragraph">
<p>O transporte nativo (ou seja, git:// URL) não faz a autenticação e deve ser utilizado com cuidado em redes sem segurança.</p>
</div>
<div class="paragraph">
<p>As seguintes sintaxes podem ser utilizadas com eles:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ssh://[user@]host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>git://host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>http[s]://host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>ftp[s]://host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Uma sintaxe alternativa como scp também pode ser utilizada com o protocolo ssh:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[user@]host.xz:caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Essa sintaxe apenas é reconhecida caso não haja barras antes dos primeiros dois pontos. Isso ajuda a diferenciar um caminho local que contém dois pontos. Por exemplo, o caminho local <code>foo:bar</code> pode ser utilizado como um caminho absoluto ou <code>./foo:bar</code> para evitar ser mal interpretado como uma url ssh.</p>
</div>
<div class="paragraph">
<p>Os protocolos ssh e git também oferecem suporte à expansão do ~nome do usuário:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ssh://[user@]host.xz[:port]/~[user]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>git://host.xz[:port]/~[user]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>[user@]host.xz:/~[user]/caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para os repositórios locais, as seguintes sintaxes podem ser utilizadas que também são compatíveis de forma nativa pelo Git:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>file:///caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Estas duas sintaxes são basicamente equivalentes, exceto durante a clonagem, quando a primeira implica no uso da opção <code>--local</code>. Para mais detalhes, consulte <a href='{{< relurl "docs/git-clone/pt_BR" >}}'>git-clone[1]</a>.</p>
</div>
<div class="paragraph">
<p>O <em>git clone</em>, <em>git fetch</em> e <em>git pull</em>, mas não o <em>git push</em>, também aceitarão um arquivo do pacote adequado. Consulte <a href='{{< relurl "docs/git-bundle/pt_BR" >}}'>git-bundle[1]</a>.</p>
</div>
<div class="paragraph">
<p>Quando o Git não sabe como lidar com um determinado protocolo de transporte, quando existe, ele tenta usar o auxiliar <code>remote-&lt;transporte&gt;</code>. Para os repositórios locais, as seguintes sintaxes podem ser utilizadas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&lt;transporte&gt;::&lt;endereço&gt;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>onde &lt;endereço&gt; pode ser um caminho, um servidor e um caminho ou uma sequência arbitrária semelhante a uma URL reconhecida por um auxiliar remoto em específico que está sendo chamado. Para mais detalhes, consulte <a href='{{< relurl "docs/gitremote-helpers/pt_BR" >}}'>gitremote-helpers[7]</a>.</p>
</div>
<div class="paragraph">
<p>Se houver um grande número de repositórios remotos com nomes semelhantes e caso queira usar um formato diferente para eles (de modo que as URLs utilizadas sejam reescritas nas URLs que funcionam), você poderá criar uma seção de configuração da opção:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "&lt;url-da-base-atual&gt;"]
		insteadOf = &lt;url-da-outra-base&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Por exemplo, com isso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "git://git.host.xz/"]
		insteadOf = host.xz:/path/to/
		insteadOf = work:</pre>
</div>
</div>
<div class="paragraph">
<p>uma URL como "work:repo.git" ou como "host.xz:/caminho/para/o/repositório.git" será reescrito em qualquer contexto onde a URL seja "git://git.host.xz/repo.git".</p>
</div>
<div class="paragraph">
<p>Caso queira reescrever apenas as URLs para envio por "push" (impulsionamento), é possível criar uma seção de configuração da opção:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "&lt;url da base atual&gt;"]
		pushInsteadOf = &lt;a url da outra base&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Por exemplo, com isso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "ssh://exemplo.org/"]
		pushInsteadOf = git://exemplo.org/</pre>
</div>
</div>
<div class="paragraph">
<p>uma URL como "git://exemplo.org/caminho/para/o/repositório.git" será reescrito para "ssh://exemplo.org/caminho/para/o/repositório.git" para os "pushes" (impulsionamentos), porém os "pulls" (obtenções) ainda usarão a URL original.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_remotos"><a class="anchor" href="#_remotos"></a>REMOTOS<a id="REMOTOS"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>O nome de um dos seguintes pode ser usado em vez de uma URL como argumento do <code>&lt;repositório&gt;</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>um ramo remoto no arquivo de configuração do Git: <code>$GIT_DIR/config</code>,</p>
</li>
<li>
<p>um arquivo no diretório <code>$GIT_DIR/remotes</code> ou</p>
</li>
<li>
<p>um arquivo no diretório <code>$GIT_DIR/branches</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Tudo isso também permite seja omitido o refspec da linha de comando, pois cada um contém um refspec que o git utilizará de maneira predefinida.</p>
</div>
<div class="sect2">
<h3 id="_ramo_remoto_nomeado_no_arquivo_de_configuração"><a class="anchor" href="#_ramo_remoto_nomeado_no_arquivo_de_configuração"></a>Ramo remoto nomeado no arquivo de configuração</h3>
<div class="paragraph">
<p>Você pode optar por informar o nome de um ramo remoto que você configurou anteriormente usando <a href='{{< relurl "docs/git-remote/pt_BR" >}}'>git-remote[1]</a>, <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a> ou até mesmo uma edição manual no arquivo <code>$GIT_DIR/config</code>. A URL deste ramo remoto será usado para acessar o repositório. É predefinido que o "refspec" deste ramo remoto será usado quando você não informar um refspec na linha de comando. A entrada no arquivo de configuração ficaria assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[remote "&lt;nome&gt;"]
		url = &lt;URL&gt;
		pushurl = &lt;pushurl&gt;
		push = &lt;refspec&gt;
		fetch = &lt;refspec&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>O <code>&lt;pushurl&gt;</code> é usado somente para envios. É opcional e o padrão é <code>&lt;URL&gt;</code>. O envio para um controle remoto afeta todos os pushurls definidos ou todos as urls definidas se não houver pushurls definidos. No entanto, o Fetch só buscará a primeira url definida caso haja várias urls definidas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arquivo_nomeado_no_git_dirremotes"><a class="anchor" href="#_arquivo_nomeado_no_git_dirremotes"></a>Arquivo nomeado no <code>$GIT_DIR/remotes</code></h3>
<div class="paragraph">
<p>Você pode optar por fornecer o nome de um arquivo em <code>$GIT_DIR/remotes</code>. A URL neste arquivo será utilizada para acessar o repositório. O "refspec" neste arquivo será utilizado como uma predefinição quando você não informar um "refspec" na linha de comando. Este arquivo deve ter o seguinte formato:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	URL: um dos formatos da URL acima
	Push: &lt;refspec&gt;
	Pull: &lt;refspec&gt;</pre>
</div>
</div>
<div class="paragraph">
<p><code>Push:</code> as linhas são usadas pelo comando <em>git push</em> e <code>Pull:</code> as linhas são usadas pelo comando <em>git pull</em> e <em>git fetch</em>. Várias linhas <code>Push:</code> e <code>Pull:</code> podem ser utilizadas para mapeamentos adicionais das ramificações.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arquivo_informado_em_git_dirbranches"><a class="anchor" href="#_arquivo_informado_em_git_dirbranches"></a>Arquivo informado em <code>$GIT_DIR/branches</code></h3>
<div class="paragraph">
<p>Você pode decidir entre informar o nome de um arquivo no <code>$GIT_DIR/branches</code>. A URL neste arquivo será utilizada para acessar o repositório. Este arquivo deve ter o seguinte formato:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	&lt;URL&gt;#&lt;head&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>A <code>&lt;URL&gt;</code> é necessária; <code>#&lt;head&gt;</code> é opcional.</p>
</div>
<div class="paragraph">
<p>Dependendo da operação, o git usará um dos seguintes refspecs, caso nenhum seja utilizado na linha de comando. O <code>&lt;ramo&gt;</code> (ramo) é o nome deste arquivo no <code>$GIT_DIR/branches</code> e <code>&lt;head&gt;</code> retorna a predefinição para <code>master</code>.</p>
</div>
<div class="paragraph">
<p>O git fetch usa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	refs/heads/&lt;head&gt;:refs/heads/&lt;ramo&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>O comando <code>git push</code> usa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	HEAD:refs/heads/&lt;head&gt;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_saída"><a class="anchor" href="#_saída"></a>SAÍDA</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O que é gerado através do "git push" depende do método de transporte utilizado; Esta seção descreve a saída gerada durante o impulsionamento através do protocolo Git (localmente ou através do ssh).</p>
</div>
<div class="paragraph">
<p>Durante um "push" a condição é que seja gerado em formato de tabela, com cada linha representando a condição de um único "ref". Cada linha é uma forma de:</p>
</div>
<div class="listingblock">
<div class="content">
<pre> &lt;flag&gt; &lt;resumo&gt; &lt;from&gt; -&gt; &lt;to&gt; (&lt;reason&gt;)</pre>
</div>
</div>
<div class="paragraph">
<p>Caso a opção <code>--porcelain</code> seja utilizado, cada linha da saída terá o formato:</p>
</div>
<div class="listingblock">
<div class="content">
<pre> &lt;flag&gt; \t &lt;from&gt;:&lt;to&gt; \t &lt;summary&gt; (&lt;reason&gt;)</pre>
</div>
</div>
<div class="paragraph">
<p>A condição das referências atualizadas é exibido apenas caso a opção <code>--porcelain</code> ou <code>--verbose</code> seja utilizada.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-push-sinalizarsinalizaoindicaomarcaomarcador"> <a class="anchor" href="#git-push-sinalizarsinalizaoindicaomarcaomarcador"></a>sinalizar, sinalização, indicação, marcação, marcador </dt>
<dd>
<p>Um único caractere indicando a condição da referência:</p>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-push-space"> <a class="anchor" href="#git-push-space"></a>(space) </dt>
<dd>
<p>para um push com avanço rápido bem sucedido;</p>
</dd>
<dt class="hdlist1" id="git-push-codecode"> <a class="anchor" href="#git-push-codecode"></a><code>+</code> </dt>
<dd>
<p>para uma imposição de atualização bem sucedida;</p>
</dd>
<dt class="hdlist1" id="git-push-code-code"> <a class="anchor" href="#git-push-code-code"></a><code>-</code> </dt>
<dd>
<p>para uma "ref" que foi excluída com sucesso;</p>
</dd>
<dt class="hdlist1" id="git-push-codecode-1"> <a class="anchor" href="#git-push-codecode-1"></a><code>*</code> </dt>
<dd>
<p>para uma nova "ref" enviada com sucesso;</p>
</dd>
<dt class="hdlist1" id="git-push-codecode-1-1"> <a class="anchor" href="#git-push-codecode-1-1"></a><code>!</code> </dt>
<dd>
<p>para uma "ref"que foi rejeitado ou não conseguiu realizar o impulsionamento "push"; e</p>
</dd>
<dt class="hdlist1" id="git-push-codecode-1-1-1"> <a class="anchor" href="#git-push-codecode-1-1-1"></a><code>=</code> </dt>
<dd>
<p>para uma "ref" que estava atualizada e não precisava do impulsionamento "push".</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-push-resumo"> <a class="anchor" href="#git-push-resumo"></a>resumo </dt>
<dd>
<p>Para uma "ref" impulsionada com sucesso, o resumo mostra os valores antigos e os novos da "ref" num formato adequado para a utilização como argumento para o comando <code>git log</code> (isso é <code>&lt;antigo&gt;..&lt;novo&gt;</code> na maioria dos casos, e <code>&lt;antigo&gt;...&lt;novo&gt;</code> para as atualizações impostas pelo avanço rápido).</p>
<div class="paragraph">
<p>Para uma atualização que falhou, mais detalhes serão dados:</p>
</div>
<div class="openblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-push-rejeitado"> <a class="anchor" href="#git-push-rejeitado"></a>rejeitado </dt>
<dd>
<p>O Git não tenta encaminhar a "ref" de forma alguma, geralmente porque não é um avanço rápido e você não impôs a atualização.</p>
</dd>
<dt class="hdlist1" id="git-push-rejeitadoremotamente"> <a class="anchor" href="#git-push-rejeitadoremotamente"></a>rejeitado remotamente </dt>
<dd>
<p>The remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: <code>receive.denyCurrentBranch</code> (for pushes to the checked out branch), <code>receive.denyNonFastForwards</code> (for forced non-fast-forward updates), <code>receive.denyDeletes</code> or <code>receive.denyDeleteCurrent</code>. See <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-push-falharemota"> <a class="anchor" href="#git-push-falharemota"></a>falha remota </dt>
<dd>
<p>O lado remoto não relatou a atualização bem-sucedida da "ref", talvez por causa de um erro temporário, uma interrupção na conexão da rede ou um outro erro transitório.</p>
</dd>
</dl>
</div>
</div>
</div>
</dd>
<dt class="hdlist1" id="git-push-de"> <a class="anchor" href="#git-push-de"></a>de </dt>
<dd>
<p>O nome do "ref" local que está sendo impulsionado, menos o seu prefixo <code>refs/&lt;tipo&gt;/</code>. No caso de exclusão, o nome do "ref" local é omitido.</p>
</dd>
<dt class="hdlist1" id="git-push-para"> <a class="anchor" href="#git-push-para"></a>para </dt>
<dd>
<p>O nome ref remoto sendo atualizado, menos o seu prefixo <code>refs/&lt;tipo&gt;/</code>.</p>
</dd>
<dt class="hdlist1" id="git-push-motivo"> <a class="anchor" href="#git-push-motivo"></a>motivo </dt>
<dd>
<p>Uma explicação legível para pessoas. No caso dos refs que forem enviados com sucesso, nenhuma explicação é necessária. Para um "ref" que falhou, o motivo do fracasso então é descrito.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nota_sobre_avanços_rápidos"><a class="anchor" href="#_nota_sobre_avanços_rápidos"></a>NOTA SOBRE AVANÇOS RÁPIDOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quando uma atualização altera um ramo (ou geralmente uma "ref") que costumava apontar para o commit <em>A</em> que aponta para outro commit <em>B</em>, é chamado de atualização de avanço rápido apenas e somente se <em>B</em> for descendente de <em>A</em>.</p>
</div>
<div class="paragraph">
<p>In a fast-forward update from A to B, the set of commits that the original commit A built on top of is a subset of the commits the new commit B builds on top of. Hence, it does not lose any history.</p>
</div>
<div class="paragraph">
<p>In contrast, a non-fast-forward update will lose history. For example, suppose you and somebody else started at the same commit X, and you built a history leading to commit B while the other person built a history leading to commit A. The history looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>      B
     /
 ---X---A</pre>
</div>
</div>
<div class="paragraph">
<p>Além disso, suponha que a outra pessoa já tenha enviado as alterações que levam "A" de volta ao repositório original, a partir do qual vocês dois obtiveram o commit "X" original.</p>
</div>
<div class="paragraph">
<p>The push done by the other person updated the branch that used to point at commit X to point at commit A. It is a fast-forward.</p>
</div>
<div class="paragraph">
<p>But if you try to push, you will attempt to update the branch (that now points at A) with commit B. This does <em>not</em> fast-forward. If you did so, the changes introduced by commit A will be lost, because everybody will now start building on top of B.</p>
</div>
<div class="paragraph">
<p>É predefinido que o comando não permita uma atualização que não seja um avanço rápido para impedir esta perda do histórico.</p>
</div>
<div class="paragraph">
<p>Caso não queira perder o seu trabalho (histórico <em>X</em> para <em>B</em>) ou o trabalho da outra pessoa (histórico de <em>X</em> para <em>A</em>), é necessário primeiro buscar o histórico no repositório, criar um histórico que contenha as alterações feitas por ambas as partes e que impulsione o resultado de volta.</p>
</div>
<div class="paragraph">
<p>You can perform "git pull", resolve potential conflicts, and "git push" the result. A "git pull" will create a merge commit C between commits A and B.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>      B---C
     /   /
 ---X---A</pre>
</div>
</div>
<div class="paragraph">
<p>A atualização de "A" com a consolidação resultante da mesclagem, avançará rapidamente e o seu envio será aceito.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can rebase your change between X and B on top of A, with "git pull --rebase", and push the result back. The rebase will create a new commit D that builds the change between X and B on top of A.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>      B   D
     /   /
 ---X---A</pre>
</div>
</div>
<div class="paragraph">
<p>Novamente, a atualização de <em>A</em> com este commit avançará rapidamente e o seu envio será aceito.</p>
</div>
<div class="paragraph">
<p>Há uma outra situação comum onde é possível encontrar uma rejeição sem avanço rápido ao tentar enviar através do "push", e é possível mesmo quando você está impulsionando para um repositório que ninguém mais faz impulsionamentos. Depois de enviar o commit <em>A</em> (na primeira foto desta seção), substitua-o pelo comando "git commit --amend" para produzir o commit <em>B</em> e tente realizar o "push", porque foi esquecido que já foi feito um push para <em>A</em>. Neste caso e somente caso tenha certeza que ninguém fez a busca pelo seu commit <em>A</em> anterior (e começou a construir em cima ele), execute o comando "git push --force" para substituí-lo. Em outras palavras, o comando "git push --force" é um método reservado para o caso onde você queira perder o histórico.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos"><a class="anchor" href="#_exemplos"></a>EXEMPLOS</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-push-codegitpushcode"> <a class="anchor" href="#git-push-codegitpushcode"></a><code>git push</code> </dt>
<dd>
<p>Funciona como <code>git push &lt;remoto&gt;</code>, onde &lt;remoto&gt; é o ramo remoto da ramificação atual (ou <code>origin</code> (origem), caso nenhum ramo remoto estiver configurado para a ramificação atual).</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushorigincode"> <a class="anchor" href="#git-push-codegitpushorigincode"></a><code>git push origin</code> </dt>
<dd>
<p>Sem uma configuração adicional, envia a ramificação atual para a upstream configurada (a variável de configuração <code>branch.&lt;name&gt;.merge</code>) caso ela tenha o mesmo nome que o ramo atual e os erros ocorrerem sem qualquer outro impulsionamento.</p>
<div class="paragraph">
<p>O comportamento predefinido deste comando quando nenhum &lt;refspec&gt; for informado, pode ser configurado definindo a opção <code>push</code> do ramo remoto ou a variável de configuração <code>push.default</code>.</p>
</div>
<div class="paragraph">
<p>For example, to default to pushing only the current branch to <code>origin</code> use <code>git config remote.origin.push HEAD</code>. Any valid &lt;refspec&gt; (like the ones in the examples below) can be configured as the default for <code>git push origin</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-push-codegitpushorigincode-1"> <a class="anchor" href="#git-push-codegitpushorigincode-1"></a><code>git push origin :</code> </dt>
<dd>
<p>Impulsiona (push) as ramificações "que coincidam" para <code>origin</code>. Consulte o &lt;refspec&gt; na seção <a href="#OPTIONS">OPTIONS</a> acima para obter uma descrição dos ramos "coincidentes".</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushoriginmastercode"> <a class="anchor" href="#git-push-codegitpushoriginmastercode"></a><code>git push origin master</code> </dt>
<dd>
<p>Find a ref that matches <code>master</code> in the source repository (most likely, it would find <code>refs/heads/master</code>), and update the same ref (e.g. <code>refs/heads/master</code>) in <code>origin</code> repository with it. If <code>master</code> did not exist remotely, it would be created.</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushoriginHEADcode"> <a class="anchor" href="#git-push-codegitpushoriginHEADcode"></a><code>git push origin HEAD</code> </dt>
<dd>
<p>Uma maneira prática de enviar a ramificação atual com o mesmo nome no ramo remoto.</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushmothershipmastersatellitemasterdevsatellitedevcode"> <a class="anchor" href="#git-push-codegitpushmothershipmastersatellitemasterdevsatellitedevcode"></a><code>git push mothership master:satellite/master dev:satellite/dev</code> </dt>
<dd>
<p>Use the source ref that matches <code>master</code> (e.g. <code>refs/heads/master</code>) to update the ref that matches <code>satellite/master</code> (most probably <code>refs/remotes/satellite/master</code>) in the <code>mothership</code> repository; do the same for <code>dev</code> and <code>satellite/dev</code>.</p>
<div class="paragraph">
<p>Consulte a seção que descreve <code>&lt;refspec&gt; ...</code> acima para uma discussão sobre a combinação semântica.</p>
</div>
<div class="paragraph">
<p>Isto serve para emular o comando <code>git fetch</code> executado na <code>mothership</code> utilizando o <code>git push</code> que é executado na direção oposta para integrar o trabalho realizado no <code>satellite</code> e geralmente é necessário quando só é possível fazer a conexão num sentido (ou seja, o satélite pode fazer uma conexão ssh com a nave mãe "mothership" mas a nave mãe não pode iniciar a conexão com o satélite porque este está atrás de um firewall ou não está executando o sshd (servidor ssh)).</p>
</div>
<div class="paragraph">
<p>Depois de executar o comando <code>git push</code> na máquina do <code>satellite</code>, você entraria na <code>mothership</code> e executaria o comando <code>git merge</code> lá para concluir a emulação do comando <code>git pull</code> executada na <code>mothership</code> para obter as alterações feitas no "satellite".</p>
</div>
</dd>
<dt class="hdlist1" id="git-push-codegitpushoriginHEADmastercode"> <a class="anchor" href="#git-push-codegitpushoriginHEADmastercode"></a><code>git push origin HEAD: master</code> </dt>
<dd>
<p>Envie o ramo atual para a referência remota que coincida com <code>master</code> no repositório <code>origin</code>. Este formulário é conveniente para impulsionar o ramo atual sem pensar no nome local.</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushoriginmasterrefsheadsexperimentalcode"> <a class="anchor" href="#git-push-codegitpushoriginmasterrefsheadsexperimentalcode"></a><code>git push origin master:refs/heads/experimental</code> </dt>
<dd>
<p>Create the branch <code>experimental</code> in the <code>origin</code> repository by copying the current <code>master</code> branch. This form is only needed to create a new branch or tag in the remote repository when the local name and the remote name are different; otherwise, the ref name on its own will work.</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushoriginexperimentalcode"> <a class="anchor" href="#git-push-codegitpushoriginexperimentalcode"></a><code>git push origin :experimental</code> </dt>
<dd>
<p>Encontre uma "ref" que coincida com <code>experimental</code> no repositório <code>origin</code> (<code>refs/heads/experimental</code> por exemplo) e exclua-a.</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushorigindevmastercode"> <a class="anchor" href="#git-push-codegitpushorigindevmastercode"></a><code>git push origin +dev:master</code> </dt>
<dd>
<p>Update the origin repository&#8217;s master branch with the dev branch, allowing non-fast-forward updates. <strong>This can leave unreferenced commits dangling in the origin repository.</strong> Consider the following situation, where a fast-forward is not possible:</p>
<div class="listingblock">
<div class="content">
<pre>	    o---o---o---A---B  origin/master
		     \
		      X---Y---Z  dev</pre>
</div>
</div>
<div class="paragraph">
<p>O comando acima alteraria o repositório de origem para</p>
</div>
<div class="listingblock">
<div class="content">
<pre>		      A---B  (ramo sem nome)
		     /
	    o---o---o---X---Y---Z  master</pre>
</div>
</div>
<div class="paragraph">
<p>Commits A and B would no longer belong to a branch with a symbolic name, and so would be unreachable. As such, these commits would be removed by a <code>git gc</code> command on the origin repository.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_segurança"><a class="anchor" href="#_segurança"></a>SEGURANÇA</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Os protocolos de busca e envio não foram projetados para impedir que um lado roube os dados do outro repositório que não deveriam ser compartilhado. Caso tenha dados particulares que precisam ser protegidos de um par malicioso, a sua melhor opção é armazená-los em um outro repositório. Isso se aplica aos clientes e aos servidores. Em particular, os espaço de nomes em um servidor não são eficazes para o controle de acesso de leitura; você só deve conceder acesso de leitura a um espaço de nomes para os clientes que você confiaria o acesso de leitura para todo o repositório.</p>
</div>
<div class="paragraph">
<p>Os vetores de ataque informados são os seguintes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A vítima envia as linhas "have" anunciando as IDs dos objetos que possui, que não são explicitamente planejados para serem compartilhados, porém podem ser usados para otimizar a transferência caso o par também os tenha. O atacante escolhe um ID do objeto <em>X</em> para roubar e envia uma "ref" para <em>X</em>, porém não é necessário enviar o conteúdo do <em>X</em> porque a vítima já o possui. Agora a vítima acredita que o atacante tem o <em>X</em> e depois envia seu conteúdo de volta ao atacante. (Esse ataque é mais simples para um cliente executar em um servidor, criando uma "ref" para <em>X</em> no espaço de nomes onde o cliente tem acesso e em seguida, buscando-o. A maneira mais provável de um servidor executá-lo em um cliente é "mesclar" <em>X</em> em um ramo público e esperar que o usuário faça um trabalho adicional neste ramo, enviá-lo de volta ao servidor sem perceber a mesclagem.)</p>
</li>
<li>
<p>As in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuração"><a class="anchor" href="#_configuração"></a>CONFIGURAÇÃO</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>pt_BR/includes/cmd-config-section-all.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>pt_BR/config/push.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>